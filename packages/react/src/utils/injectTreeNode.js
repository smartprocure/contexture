import React from 'react'
import { observer } from 'mobx-react'
import _ from 'lodash/fp'
import StripedLoader from './StripedLoader'

export let withNode = (Component, { allowEmptyNode = false } = {}) => 
  ({ tree, node, path, ...props }) => {
    node = node || tree.getNode(path)
  
    if (!node && path && !allowEmptyNode)
      throw Error(`Node not provided, and couldn't find node at ${path}`)
      
    return <Component {...{tree, node, path, ...props}} />
  }

export let withAutoAdd = (Component, type) => ({ tree, node, group, path, nodeProps, nodeKey, ...props }) => {
  group = group || path && _.initial(path) || _.get('tree.path', tree)
  nodeKey = nodeKey || _.last(path)

  // if a key is given, we should see if the node already exists before trying to autogen
  if (!node && nodeKey) node = tree.getNode([...group, nodeKey])
  
  if (!node) {
    if (!type)
      throw Error(`Node not provided and cannot be autogenerated ('type' property is required)`)
  
    // now that client exposes `types` on the tree, we can look up the type object instead of having to pass it in
    nodeProps = nodeProps || _.flow(_.get(['types', type, 'reactors']), _.keys)(tree)
    let newNode = { type, key: nodeKey, ..._.pick(['field', ...nodeProps], props) }
    // relies on client update to await dispatch and return new node on `tree.add`
    node = tree.add(group, newNode)

    if (!node) throw Error(`Unable to add node ${JSON.stringify(newNode)}`)
  }

  // TODO: this still passes through any stuff that's just for nodeProps, though it probably shouldn't
  return <Component {...{ tree, node, path, ...props }} />
}

export let withLoader = Component => observer(
  ({ Loader = StripedLoader, node, ...props }) => (
    <Loader loading={node.updating}>
      <Component node={node} {...props} />
    </Loader>
  )
)

export let withEmptyNodeError = Component => ({ node, ...props }) => {
  if (!node) throw Error(`Node not provided`)

  return <Component node={node} {...props} />
}

export default _.flow(withNode, withLoader)
