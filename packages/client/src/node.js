import _ from 'lodash/fp.js'
import F from 'futil'
import { Tree, encode, anyLeaves, allLeaves } from './util/tree.js'
import {
  runTypeFunction,
  runTypeFunctionOrDefault,
  getTypeProp,
} from './types.js'

export let defaults = {
  type: null,
  paused: null,
  path: null,
  updating: null,
  lastUpdateTime: null,
  markedForUpdate: null,
  isStale: null,
  hasValue: null,
  hasResults: null,
  error: null,
  context: null,
  missedUpdate: null,
  updatingPromise: null,
  updatingDeferred: null,
  metaHistory: [],
}
export let internalStateKeys = [
  ..._.keys(_.omit(['type', 'paused'], defaults)),
  'validate',
  'onMarkForUpdate',
  'afterSearch',
  'forceReplaceResponse',
  'expand',
  'collapse',
  'someError',
  'everyPaused',
]

export let autoKey = (x) => F.compactJoin('-', [x.field, x.type]) || 'node'

export let initNode = _.curry((actionProps, dedupe, parentPath, node) => {
  let { types, extend, snapshot } = actionProps

  runTypeFunction(types, 'init', node, actionProps)
  let key = dedupe(
    node.key ||
      runTypeFunctionOrDefault(autoKey, types, 'autoKey', node, actionProps)
  )
  extend(node, {
    ..._.omit(_.keys(node), defaults),
    // For some reason, type defaults can end up observable in real world apps, so we `snapshot` instead of `_.deepClone`
    ..._.omit(_.keys(node), snapshot(getTypeProp(types, 'defaults', node))),
    key,
    path: [...parentPath, key],
    ...(node.children && {
      someError: () => anyLeaves('error', node),
      everyPaused: () => allLeaves('paused', node),
    }),
  })
})

// fn: (dedupe: string -> string, parentPath: array, node: object) -> void
export let dedupeWalk = (fn, tree, { target = {}, dedupe } = {}) => {
  // allows us to maintain separate deduplication caches for each node's children by
  // storing a `uniqueString` instance in `dedupes` with that node's path as its key.
  // this ensures that autogenerated node keys will always be unique from their siblings,
  // but won't be unnecessarily modified if they are duplicates of keys in other branches.
  let dedupes = target.path ? { [encode(target.path)]: dedupe } : {}
  Tree.walk((node, index, [parent = {}]) => {
    let parentPath = parent.path || target.path || []
    fn(dedupes[encode(parentPath)] || _.identity, parentPath, node)
    dedupes[encode(node.path)] = F.uniqueString([])
  })(tree)
}

export let hasContext = (node) => node && node.context
let throwsError = (x) => {
  throw Error(x)
} // Throw expressions are stage 3 :(
export let hasValue = (node) =>
  node && _.isUndefined(node.hasValue)
    ? throwsError('Node was never validated')
    : node && node.hasValue && !node.error

// Work around mobx array detection because `_.isArray(mobxArray) !== true`
const isArrayLike = (x) =>
  x && !_.isString(x) && _.isFunction(x[Symbol.iterator])

const isTraversable = (x) => _.isPlainObject(x) || isArrayLike(x)

export let hasResults = (node) =>
  !!F.findNode()((node) => {
    if (!isTraversable(node)) {
      return F.isNotBlank(node)
    }
  }, node.context)
