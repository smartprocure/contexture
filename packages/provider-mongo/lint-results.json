[{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/bool.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/date.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/dateHistogram.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/default.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/exists.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/facet.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/mongoId.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/number.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/results.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/statistical.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/tagsText.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/termsStats.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/example-types/text.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/src/index.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/bool.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/date.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/dateHistogram.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/exists.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/facet.js","messages":[{"ruleId":"arrow-body-style","severity":2,"message":"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.","line":461,"column":33,"nodeType":"ArrowFunctionExpression","source":"      let collection = _.map(x=>{return {_id:ObjectID(x['_id']),name:x.name}},data)","messageId":"unexpectedObjectBlock","fix":{"range":[13550,13595],"text":"({_id:ObjectID(x['_id']),name:x.name})"}},{"ruleId":"no-undef","severity":2,"message":"'node' is not defined.","line":464,"column":7,"nodeType":"Identifier","source":"      node ={","endLine":464,"endColumn":11},{"ruleId":"object-shorthand","severity":2,"message":"Expected property shorthand.","line":470,"column":11,"nodeType":"Property","source":"          collection: collection,","endLine":470,"endColumn":33,"fix":{"range":[13861,13883],"text":"collection"}},{"ruleId":"no-undef","severity":2,"message":"'node' is not defined.","line":485,"column":39,"nodeType":"Identifier","source":"      let result = await facet.result(node, agg =>","endLine":485,"endColumn":43}],"errorCount":4,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"let { expect } = require('chai')\nlet _ = require('lodash/fp')\nlet facet = require('../../src/example-types/facet')\nlet { ObjectID } = require('mongodb')\nlet mingo = require('mingo')\n\ndescribe('facet', () => {\n  describe('facet.hasValue', () => {\n    it('Should allow nodes with values', () => {\n      expect(\n        facet.hasValue({\n          values: [1, 2],\n        })\n      ).to.equal(2)\n    })\n    it('Should not allow nodes with values', () => {\n      expect(\n        facet.hasValue({\n          values: [],\n        })\n      ).to.equal(0)\n    })\n  })\n  describe('facet.result', () => {\n    let queries = []\n    let search = async query => {\n      queries.push(query)\n      return [1, 2, 3].map(i => ({ _id: `${i}`, count: i }))\n    }\n    it('should call the search function and wait for it', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n      }\n      let result = await facet.result(node, search)\n      expect(result.options.length).to.equal(3)\n      expect(_.every(x => _.isNumber(x.count), result.options)).to.equal(true)\n    })\n    it('should default the limit query to 10 if size is not provided', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n      }\n      await facet.result(node, search)\n      let limitAgg = _.find('$limit', queries[0])\n      expect(limitAgg.$limit).to.equal(10)\n    })\n    it('should allow unlimited queries', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n        size: 0,\n      }\n      await facet.result(node, search)\n      let limitAgg = _.find('$limit', queries[0])\n      expect(limitAgg).to.be.undefined\n    })\n    it('should support optionsFilter', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n        optionsFilter: 'cable',\n      }\n      await facet.result(node, search)\n      let filterAgg = _.find('$match', queries[0])\n      expect(filterAgg).to.deep.equal({\n        $match: {\n          _id: {\n            $regex: '.*(?=.*cable.*).*',\n            $options: 'i',\n          },\n        },\n      })\n      // Also make sure that options filtering happens _before_ limiting\n      let filterIndex = _.findIndex('$match', queries[0])\n      let limitIndex = _.findIndex('$limit', queries[0])\n      expect(limitIndex > filterIndex).to.be.true\n    })\n    it('should support optionsFilter with multiple words and spaces', async () => {\n      queries = []\n      let node = {\n        field: 'categoriesInfo',\n        optionsFilter: '  dis  comp    ',\n      }\n      await facet.result(node, search)\n      let filterAgg = _.find('$match', queries[0])\n      expect(filterAgg).to.deep.equal({\n        $match: {\n          _id: {\n            $regex: '.*(?=.*dis.*)(?=.*comp.*).*',\n            $options: 'i',\n          },\n        },\n      })\n      // Also make sure that options filtering happens _before_ limiting\n      let filterIndex = _.findIndex('$match', queries[0])\n      let limitIndex = _.findIndex('$limit', queries[0])\n      expect(limitIndex > filterIndex).to.be.true\n    })\n    it('should sort and limit results as early as possible if there is no search, for performance benefits', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n        label: 'myField',\n      }\n\n      await facet.result(node, search)\n\n      let sortIndex = _.findIndex('$sort', queries[0])\n      let limitIndex = _.findIndex('$limit', queries[0])\n\n      let lastIndex = queries[0].length - 1\n      let secondToLastIndex = lastIndex - 1\n\n      expect(limitIndex > sortIndex).to.be.true\n      expect(sortIndex < secondToLastIndex).to.be.true\n      expect(limitIndex < lastIndex).to.be.true\n    })\n    it('should sort and limit results later in the pipeline if there is a facet search', async () => {\n      queries = []\n      let node = {\n        field: 'myField',\n        label: 'myField',\n        optionsFilter: 'keyword',\n      }\n\n      await facet.result(node, search)\n\n      let sortIndex = _.findIndex('$sort', queries[0])\n      let limitIndex = _.findIndex('$limit', queries[0])\n\n      let lastIndex = queries[0].length - 1\n      let secondToLastIndex = lastIndex - 1\n\n      expect(limitIndex > sortIndex).to.be.true\n      expect(sortIndex === secondToLastIndex).to.be.true\n      expect(limitIndex === lastIndex).to.be.true\n    })\n    it('should support isMongoId', async () => {\n      let node = {\n        field: 'field',\n        values: ['5a4ea8052c635b002ade8e45', '5a4ea8052c635b002ade8e45'],\n      }\n      let result = await facet.filter(node)\n      expect(result.field.$in.map(x => x.toString())).to.deep.equal([\n        '5a4ea8052c635b002ade8e45',\n        '5a4ea8052c635b002ade8e45',\n      ])\n    })\n    it('should support string label lookups', async () => {\n      let activities = [\n        { _id: 1, type: 'create', user: 2 },\n        { _id: 1, type: 'update', user: 1 },\n        { _id: 1, type: 'create', user: 1 },\n        { _id: 1, type: 'delete', user: 3 },\n        { _id: 1, type: 'delete', user: 2 },\n        { _id: 1, type: 'read', user: 1 },\n      ]\n\n      let users = [\n        { _id: 1, name: 'Fred', type: 'basic' },\n        { _id: 2, name: 'Jane', type: 'admin' },\n      ]\n\n      let node = {\n        field: 'user',\n        label: {\n          collection: users,\n          foreignField: '_id',\n          fields: 'name',\n        },\n      }\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(activities, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 3,\n        options: [\n          { name: 1, label: 'Fred', count: 3 },\n          { name: 2, label: 'Jane', count: 2 },\n          { name: 3, count: 1 },\n        ],\n      })\n    })\n    it('should support array label lookups', async () => {\n      let activities = [\n        { _id: 1, type: 'create', user: 2 },\n        { _id: 1, type: 'update', user: 1 },\n        { _id: 1, type: 'create', user: 1 },\n        { _id: 1, type: 'delete', user: 3 },\n        { _id: 1, type: 'delete', user: 2 },\n        { _id: 1, type: 'read', user: 1 },\n      ]\n\n      let users = [\n        { _id: 1, firstName: 'Fred', lastName: 'Smith', type: 'basic' },\n        { _id: 2, firstName: 'Jane', lastName: 'Williams', type: 'admin' },\n      ]\n\n      let node = {\n        field: 'user',\n        label: {\n          collection: users,\n          foreignField: '_id',\n          fields: ['firstName', 'lastName'],\n        },\n      }\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(activities, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 3,\n        options: [\n          {\n            name: 1,\n            label: { firstName: 'Fred', lastName: 'Smith' },\n            count: 3,\n          },\n          {\n            name: 2,\n            label: { firstName: 'Jane', lastName: 'Williams' },\n            count: 2,\n          },\n          { name: 3, count: 1 },\n        ],\n      })\n    })\n    it('should ignore label lookup when not present', async () => {\n      let activities = [\n        { _id: 1, type: 'create', user: 2 },\n        { _id: 1, type: 'update', user: 1 },\n        { _id: 1, type: 'create', user: 1 },\n        { _id: 1, type: 'delete', user: 3 },\n        { _id: 1, type: 'delete', user: 2 },\n        { _id: 1, type: 'read', user: 1 },\n      ]\n\n      let node = {\n        field: 'user',\n      }\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(activities, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 3,\n        options: [\n          { name: 1, count: 3 },\n          { name: 2, count: 2 },\n          { name: 3, count: 1 },\n        ],\n      })\n    })\n    it('should support optionsFilter with a lookup that returns a single field', async () => {\n      queries = []\n\n      let activities = [\n        { _id: 1, type: 'create', user: 2 },\n        { _id: 1, type: 'update', user: 1 },\n        { _id: 1, type: 'create', user: 1 },\n        { _id: 1, type: 'delete', user: 3 },\n        { _id: 1, type: 'delete', user: 2 },\n        { _id: 1, type: 'read', user: 1 },\n      ]\n\n      let users = [\n        { _id: 1, firstName: 'Fred', type: 'basic' },\n        { _id: 2, firstName: 'Jane', type: 'admin' },\n      ]\n\n      let node = {\n        field: 'user',\n        optionsFilter: 'jane',\n        label: {\n          collection: users,\n          foreignField: '_id',\n          fields: 'firstName',\n        },\n      }\n\n      await facet.result(node, search)\n      let filterAgg = _.find('$match', queries[0])\n      expect(filterAgg).to.deep.equal({\n        $match: {\n          'label.firstName': {\n            $regex: '.*(?=.*jane.*).*',\n            $options: 'i',\n          },\n        },\n      })\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(activities, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 3,\n        options: [\n          {\n            name: 2,\n            label: 'Jane',\n            count: 2,\n          },\n        ],\n      })\n    })\n    it('should support a lookup with an optionsFilter with multiple keywords that span multiple fields', async () => {\n      queries = []\n\n      let activities = [\n        { _id: 1, type: 'create', user: 2 },\n        { _id: 1, type: 'update', user: 1 },\n        { _id: 1, type: 'create', user: 1 },\n        { _id: 1, type: 'delete', user: 3 },\n        { _id: 1, type: 'delete', user: 2 },\n        { _id: 1, type: 'read', user: 1 },\n      ]\n\n      let users = [\n        { _id: 1, firstName: 'Fred', lastName: 'Smith', type: 'basic' },\n        { _id: 2, firstName: 'Jane', lastName: 'Williams', type: 'admin' },\n      ]\n\n      let node = {\n        field: 'user',\n        optionsFilter: 'fred smith',\n        label: {\n          collection: users,\n          foreignField: '_id',\n          fields: ['firstName', 'lastName'],\n        },\n      }\n\n      await facet.result(node, search)\n      let filterAgg = _.find('$match', queries[0])\n      expect(filterAgg).to.deep.equal({\n        $match: {\n          $and: [\n            {\n              $or: [\n                {\n                  'label.firstName': {\n                    $regex: '.*(?=.*fred.*).*',\n                    $options: 'i',\n                  },\n                },\n                {\n                  'label.lastName': {\n                    $regex: '.*(?=.*fred.*).*',\n                    $options: 'i',\n                  },\n                },\n              ],\n            },\n            {\n              $or: [\n                {\n                  'label.firstName': {\n                    $regex: '.*(?=.*smith.*).*',\n                    $options: 'i',\n                  },\n                },\n                {\n                  'label.lastName': {\n                    $regex: '.*(?=.*smith.*).*',\n                    $options: 'i',\n                  },\n                },\n              ],\n            },\n          ],\n        },\n      })\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(activities, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 3,\n        options: [\n          {\n            name: 1,\n            label: { firstName: 'Fred', lastName: 'Smith' },\n            count: 3,\n          },\n        ],\n      })\n    })\n    it('should allow for an optional node.unwind to distinguish a nested array field being searched', async () => {\n      let collection = [\n        {\n          _id: 1,\n          myFields: [\n            {\n              _id: 5,\n              field: 'firstField',\n            },\n          ],\n        },\n        {\n          _id: 2,\n          myFields: [\n            {\n              _id: 6,\n              field: 'firstField',\n            },\n            {\n              _id: 7,\n              field: 'secondField',\n            },\n          ],\n        },\n      ]\n\n      let node = {\n        field: 'myFields.field',\n        unwind: 'myFields',\n      }\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(collection, agg)\n      )\n\n      expect(result).to.deep.equal({\n        cardinality: 2,\n        options: [\n          { name: 'firstField', count: 2 },\n          { name: 'secondField', count: 1 },\n        ],\n      })\n    })\n    it('should return correct search result when checked value missing', async () => {\n\n      let data = [\n        { _id: '5e9dbd76e991760021124966', name: 'Automation' },\n        { _id: '5cde2658dc766b0030c67dae', name: 'Fowlkes (MO)' },\n        { _id: '5ebef03a06acda0021797bfd', name: 'Automation' },\n        { _id: '5cde259edc766b0030c67d9e', name: 'Lombardi (AR)' },\n        { _id: '5ea6e54479a8c60021156015', name: 'Automation' },\n        { _id: '5cde25bedc766b0030c67da1', name: 'Whipple' },\n        { _id: '5ee1378770824e00213ffe07', name: 'Katalon Test' },\n        { _id: '5ea1e2ccc2ce7b0022c2655a', name: 'Automation' },\n        { _id: '5ebabd429a42630021a86a35', name: 'Finance' },\n        { _id: '5e5e9b2bdda1c5002bdb9e9f', name: 'Silver Cooper' },\n        { _id: '5d52fea84e01ee003782da3e', name: 'Andrea Restrepo ' },\n        { _id: '5f0f2bc8c66f260021280d37', name: 'Automation' },\n        { _id: '5ce3f7a1c5b085002cb2a330', name: 'Stephen Mailloux' },\n        { _id: '5f208018ddcb610021a43d82', name: 'Automation' },\n        { _id: '5ea86df23aab7500215be93a', name: 'Automation' },\n        { _id: '5cde208b87eff60030d9c0b1', name: 'Morris (RJ)' },\n        { _id: '5f032194fefab4002119ce92', name: 'Katalon Test' },\n        { _id: '5d1ca49436e1d20038f8c84f', name: 'Customer Experience' },\n        { _id: '5ce30b403aa154002d01b9ed', name: 'Government Division' },\n      ]\n      let collection = _.map(x=>{return {_id:ObjectID(x['_id']),name:x.name}},data)\n\n      //5d1ca49436e1d20038f8c84f and 5ce30b403aa154002d01b9ed are the values from buttom of the records they are missing values\n      node ={\n        key: 'id',\n        field: '_id',\n        type: 'facet',\n        isMongoId: true,\n        label: {\n          collection: collection,\n          foreignField: '_id',\n          fields: [ 'name' ]\n        },\n        values: [\n          '5d1ca49436e1d20038f8c84f',\n          '5ce30b403aa154002d01b9ed',\n          '5e9dbd76e991760021124966',\n          '5cde2658dc766b0030c67dae'\n        ],\n        mode: 'include',\n        optionsFilter: '',\n        size: 10,\n      }\n\n      let result = await facet.result(node, agg =>\n        mingo.aggregate(collection, agg)\n      )\n      let ids = (_.map((x)=>_.toString(x.name),result.options))\n\n      expect(result.options.length).to.equal(10)\n      expect(_.includes('5d1ca49436e1d20038f8c84f',ids)).to.be.true\n      expect(_.includes('5ce30b403aa154002d01b9ed',ids)).to.be.true\n      expect(_.includes('5e9dbd76e991760021124966',ids)).to.be.true\n      expect(_.includes('5cde2658dc766b0030c67dae',ids)).to.be.true\n    })\n  })\n})\n"},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/mongoId.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/number.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/results.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/statistical.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/termsStats.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"/Users/chrislei/Documents/GovSpend/contexture-mongo/test/example-types/text.js","messages":[],"errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0}]